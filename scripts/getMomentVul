#!/usr/bin/env python
# -*- coding: utf-8 -*-
from __future__ import unicode_literals
from __future__ import print_function
from io import open
import numpy as np
from intervul.readpos import VulcanPosMesh
from intervul.general import Submesh
import os
import argparse
import re

def get_direction_from_string(text):
    if direction.startswith('['):
        # Separa la lista y normaliza el vector
        direction = re.split(' +|, *', direction[1:-1])
        direction = [float(x) for x in direction]
        norm = np.linalg.norm(direction)
        direction = [x/norm for x in direction]
    elif direction.lower().startswith('x'):
        direction = [1.0, 0, 0]
    elif direction.lower().startswith('y'):
        direction = [0, 1.0, 0]
    elif direction.lower().startswith('z'):
        direction = [0, 0, 1.0]
    else:
        raise ValueError("Direction mal formed")

    return direction


parser = argparse.ArgumentParser(
    description='Extrae las fuerzas de un set en particular')
parser.add_argument(
        '-s',
        '--set',
        help='Indica de que set quieres obtener la fuerza',
        default=1,
        type=int)
parser.add_argument(
        '-d',
        '--direction',
        help='Define en que dirección se quiere la fuerza.'
             '"x", "y", "z" o "[1.0, 1.0, 1.0]"',
        default='x')
parser.add_argument(
        '-p',
        '--position',
        help='Posicion desde la cual se momenta.'
             '"x", "y", "z" o "[1.0, 1.0, 1.0]"',
        default='x')
parser.add_argument(
        '-l',
        '--listofnodes',
        help='Toma esta lista de nodos para calcular las fuerzas (sobrescribe --set)',
        type=argparse.FileType('r'))
parser.add_argument(
        '-o',
        '--fileOutput',
        help='Indica el nombre del archivo de salida (default: moments.txt)',
        default="moments.txt",
        )
parser.add_argument('fileIn', help="Archivo de dato")

args = parser.parse_args()

filename = args.fileIn
fileout = args.fileOutput
# el set está en forma de base 0 (parte de 0)
setForce = args.set - 1
direction = get_direction_from_string(args.direction)
position = get_direction_from_string(args.position)
nodesfile = args.listofnodes

data = VulcanPosMesh(filename, VulcanPosMesh.MECHANICAL)
mesh = data.mesh

if nodesfile is not None:
    nodes = np.loadtxt(nodesfile)
else:
    submesh = Submesh(setNum=setForce)
    submesh.getSet(mesh=mesh)
    nodes = submesh.inodeOriginal

posInitial = mesh.nodes[nodes]

print(fileout)
firstPass = True
with open(fileout, 'w', encoding='utf-8') as f:
    for istep, result in data:
        if firstPass:
            f.write("# Reaction moment of case\n")
            f.write("# " + result['titleResult'].decode('utf-8').strip() + "\n")
            f.write("# filename: " + filename + "\n")
            if nodeList:
                f.write("# file of nodes: " + nodesfile.name + "\n")
            else:
                f.write("# set: " + str(setForce + 1) + "\n")
            f.write("# direction: " + str(direction) + "\n")
            f.write("# Time Displacement Moment\n")
            if nodeList:
                print("Extracting forces for filename " + filename + " in list "
                      "of nodes " + nodesfile.name)
            else:
                print("Extracting forces for filename " + filename + " in set " +
                      str(setForce + 1))
            firstPass = False

        reactionsPerNode = result['reaction'][nodes,:]
        displacementPerNode = result['displacement'][nodes,:]
        finalPos = initPos + displacementPerNode
        relativePos = finalPos - position
        momentPerNode = np.cross(relativePos, reactionsPerNode)
        moment = np.einsum("ij,j -> ", momentPerNode, direction)
        text = "{:8.3f} {:14.6E}".format(result['TimeValue'], moment)
        print(text)
        f.write(text + "\n")
